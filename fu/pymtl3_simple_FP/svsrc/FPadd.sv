//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /nobackup-02/ajokai/eee498/apr/FPadd_plain_mode_noMode_16b_3EffSc_950ps/rtl/FPadd_plain.vp
//  Source template: FPadd_plain
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter BW 	= 16
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------





// BW (_GENESIS2_INHERITANCE_PRIORITY_) = 16
//



// DPDA_ 
module FPadd_plain
(
   //input logic clk,
   //input logic rst,
   //Inputs   
   input logic [15:0] rhs_0,
   input logic [15:0] rhs_1,
   //Outputs   
   output logic [15:0] lhs_0
);
  
  logic a_s;
  logic b_s;
  logic [4:0] a_e;
  logic [4:0] b_e;
  logic [9:0] a_m;
  logic [9:0] b_m;

  assign a_s = rhs_0[15];
  assign b_s = rhs_1[15];
  assign a_e = rhs_0[14:10];
  assign b_e = rhs_1[14:10];
  assign a_m = rhs_0[9:0];
  assign b_m = rhs_1[9:0];



  logic signed [5:0] a_eMINUSb_e; // One bit wider.
  assign a_eMINUSb_e = signed'({1'b0, a_e}) - signed'({1'b0, b_e});
    

  logic unsigned [4:0] largerExp;
  assign largerExp = a_eMINUSb_e[5] ? b_e : a_e;

  logic unsigned [9:0] smallerMan;
  assign smallerMan = a_eMINUSb_e[5] ? a_m : b_m;

  logic unsigned [9:0] largerMan;
  assign largerMan = a_eMINUSb_e[5] ? b_m : a_m;



  logic signed [11:0] leadingOneSmall_m;
  logic signed [11:0] leadingOneLarge_m;

  assign leadingOneSmall_m = {2'b01, smallerMan};
  assign leadingOneLarge_m = {2'b01, largerMan};



  logic signed [11:0] leadingOneSmall_m_shifted;
  logic unsigned [5:0] shifter;
  assign shifter = ((a_eMINUSb_e ^ {6{a_eMINUSb_e[5]}}) + a_eMINUSb_e[5]);
  assign leadingOneSmall_m_shifted = (leadingOneSmall_m >> shifter);



  logic signed [11:0] arg0;
  logic signed [11:0] arg1;
  assign arg0 = (leadingOneSmall_m_shifted ^ {12{a_eMINUSb_e[5] ? a_s : b_s}}) + (a_eMINUSb_e[5] ? a_s : b_s);
  assign arg1 = (leadingOneLarge_m         ^ {12{a_eMINUSb_e[5] ? b_s : a_s}}) + (a_eMINUSb_e[5] ? b_s : a_s);

  logic signed [11:0] big_adder;
  //assign big_adder = arg0 + arg1;
  assign big_adder = (leadingOneSmall_m_shifted ^ {12{a_eMINUSb_e[5] ? a_s : b_s}}) + (a_eMINUSb_e[5] ? a_s : b_s) +
                     (leadingOneLarge_m         ^ {12{a_eMINUSb_e[5] ? b_s : a_s}}) + (a_eMINUSb_e[5] ? b_s : a_s);


  logic signed [11:0] big_adder_ov_fix;
  logic big_adder_ov_fix_condition;
  assign big_adder_ov_fix_condition = ((arg0[11] & arg1[11] & ~big_adder[11]) | (~arg0[11] & ~arg1[11] & big_adder[11])); // 1 1 0 or 0 0 1
  assign big_adder_ov_fix = big_adder_ov_fix_condition ? {~big_adder[11], big_adder[11:1]} : big_adder;


  logic unsigned [11:0] big_adder_amplitude; // Absolute value of the summation.
  assign big_adder_amplitude = (big_adder_ov_fix ^ {12{big_adder_ov_fix[11]}}) + big_adder_ov_fix[11];


  logic unsigned [3:0] priEnc; // Highest priEnc value is '$man.'

  always_comb
    priority casez (big_adder_amplitude)
      //12'b1???????????: priEnc = 4'd0;
      12'b01??????????: priEnc = 4'd0;
      12'b001?????????: priEnc = 4'd1;
      12'b0001????????: priEnc = 4'd2;
      12'b00001???????: priEnc = 4'd3;
      12'b000001??????: priEnc = 4'd4;
      12'b0000001?????: priEnc = 4'd5;
      12'b00000001????: priEnc = 4'd6;
      12'b000000001???: priEnc = 4'd7;
      12'b0000000001??: priEnc = 4'd8;
      12'b00000000001?: priEnc = 4'd9;
      12'b000000000001: priEnc = 4'd10;
      default: priEnc = 4'b0; // TODO, what to do if the adder output is all zeros?
    endcase

  // Not dealing with subnormal numbers.
  // If the result is too small (exponent would be less than one),
  // set the output to the smallest possible number.
  // TODO: What about too big? When exponent is more than e.g. 11110.
  // TODO: What if the result is zero? Exponent and mantissa have to be both zero.
 
  assign lhs_0[15] = big_adder_ov_fix[11];

  //assign lhs_0[14:10] = (largerExp <= priEnc) ? 5'b1 : (largerExp - priEnc + big_adder_ov_fix_condition);
  //assign lhs_0[9:0] = (largerExp <= priEnc) ? 10'b0 : (big_adder_amplitude << priEnc);

  logic unsigned [5:0] result_exp;
  assign result_exp = largerExp - priEnc + big_adder_ov_fix_condition;

  always_comb
    unique case (1'b1)
      (result_exp[5] | ~|result_exp): lhs_0[14:10] = 5'b1;
      (big_adder_amplitude[11]): lhs_0[14:10] = largerExp + 1'b1;
      default: lhs_0[14:10] = result_exp;
    endcase

  always_comb
    unique case (1'b1)
      (result_exp[5] | ~|result_exp): lhs_0[9:0] = 10'b0;
      (big_adder_amplitude[11]): lhs_0[9:0] = big_adder_amplitude[10:1];
      default: lhs_0[9:0] = (big_adder_amplitude << priEnc);
    endcase


   
endmodule

