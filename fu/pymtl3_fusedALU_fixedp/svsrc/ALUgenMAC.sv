//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /mnt/nobackup-02/ajokai/eee498/source/rtl/ALUgen.vp
//  Source template: ALUgen
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter AddMultExternal 	= 0
// Parameter ALU_MODE 	= 6
// Parameter BW 	= 16
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------


// ALU_MODE (_GENESIS2_INHERITANCE_PRIORITY_) = 6
//
// BW (_GENESIS2_INHERITANCE_PRIORITY_) = 16
//
// AddMultExternal (_GENESIS2_INHERITANCE_PRIORITY_) = 0
//

// The ALUs' input connections to the adder are output ports, the ouput connection is an input port, so the adder can be instantiated and connected accordingly.

// DPDA_

`ifdef VCS
`include "DW02_multp.v"
`endif

module ALUgenMAC
(
   //Inputs   
   input logic signed [15:0] rhs_0,
   input logic signed [15:0] rhs_1,
   input logic signed [15:0] rhs_1b,
   input logic [5:0] rhs_2,
   // Outputs   
   output logic signed [15:0] lhs_0


   //input logic clk,
   //input logic rst
);

  // Adder IF.
  logic [15:0] adder_in_1;
  logic [15:0] adder_in_2;
  logic adder_in_cin;
  logic [15:0] adder_out;

  assign adder_out = adder_in_1 + adder_in_2 + adder_in_cin;

  // MULTP IF.
  logic [15:0] multp_in_1;
  logic [15:0] multp_in_2;
  logic [33:0] multp_out_1;
  logic [33:0] multp_out_2;

  logic tc;
  assign tc = 1'b0;

  DW02_multp #(16, 16, 34)
          U1 ( 
	     .a(signed'(multp_in_1)),
	     .b(signed'(multp_in_2)),
	     .tc(tc),
             .out0(multp_out_1),
	     .out1(multp_out_2)
	     );


  logic [15:0] a;
  logic [15:0] b;
  logic [15:0] c;
  assign a = multp_out_1[15:0];
  assign b = multp_out_2[15:0];
  assign c = {16{rhs_2[5]}} & rhs_1b;

  logic [15:0] T;
  logic [16:0] U;
  assign T = a ^ b ^ c;
  assign U = {((a & b) | (a & c) | (b & c)), 1'b0};

  assign multp_in_1   = {16{rhs_2[4]}} & rhs_0;
  assign multp_in_2   = {16{rhs_2[4]}} & rhs_1;
  assign adder_in_1   = rhs_2[4] ? T : ({16{rhs_2[3]}} ^ rhs_0);
  assign adder_in_2   = rhs_2[4] ? U[15:0] : ({16{rhs_2[0]}} ^ rhs_1);
  assign adder_in_cin = rhs_2[0] | rhs_2[3];
  assign lhs_0        = rhs_2[1] ? {15'b0, (rhs_2[2] ^ adder_out[15])} : adder_out;




   
endmodule

